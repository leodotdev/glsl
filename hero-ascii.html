<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ASCII Hero</title>
    <style>
        @font-face {
            font-family: 'PPSupplyMono';
            src: url('./fonts/PPSupplyMono-Regular.otf') format('opentype');
            font-weight: normal;
            font-style: normal;
        }
        
        body {
            margin: 0;
            font-family: 'PPSupplyMono', monospace;
            overflow: hidden;
        }
        
        #ascii-hero {
            position: relative;
            width: 100%;
            height: 100vh; /* Adjust as needed */
            background: #000;
        }
        
        #canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        /* Optional: Overlay content on top of the ASCII effect */
        .hero-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #fff;
            z-index: 10;
            pointer-events: none; /* Allow interaction with 3D model behind */
        }
        
        .hero-content h1 {
            font-size: 3rem;
            margin: 0;
            /* Add text shadow for better readability */
            text-shadow: 0 0 20px rgba(0,0,0,0.8);
        }
    </style>
</head>
<body>
    <div id="ascii-hero">
        <canvas id="canvas"></canvas>
        <!-- Optional: Add your hero content here -->
        <!--
        <div class="hero-content">
            <h1>Your Title Here</h1>
            <p>Your subtitle or description</p>
        </div>
        -->
    </div>

    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.149.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.149.0/examples/jsm/"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer;
        let model, controls;
        let asciiPass;
        let fontLoaded = false;

        // ASCII character set
        let fullAsciiSet = " `'.·:;,_-~^\"!|/\\()[]{}+<>=*?¿•○●#$%&@";
        fullAsciiSet += "¡¦†‡§¶¤¢£¥™®©÷×±¬";
        fullAsciiSet += "ilI7TYJj1089";

        let asciiTexture = null;

        // Configuration options - adjust these as needed
        const config = {
            modelPath: '3d/untitled-12.glb',
            autoRotate: true,
            rotationSpeed: 0.01,
            charSize: 10,
            brightness: 1.1,
            contrast: 1.1,
            enableOrbitControls: true, // Set to false to disable user interaction
            cameraDistance: 5
        };

        // Wait for font to load
        const font = new FontFace('PPSupplyMono', 'url(./fonts/PPSupplyMono-Regular.otf)');
        font.load().then((loadedFont) => {
            document.fonts.add(loadedFont);
            fontLoaded = true;
            init();
        }).catch(err => {
            console.error('Font loading error:', err);
            fontLoaded = true;
            init(); // Still init even if font fails
        });

        // Create ASCII texture atlas
        function createAsciiTexture(charSet = fullAsciiSet) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            const charSize = 32;
            const cols = 16;
            const rows = Math.ceil(charSet.length / cols);
            
            canvas.width = charSize * cols;
            canvas.height = charSize * rows;
            
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.font = `${charSize * 0.8}px PPSupplyMono, monospace`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = '#fff';
            
            // Debug: Check if font is applied
            console.log('Font being used:', ctx.font);
            
            for (let i = 0; i < charSet.length; i++) {
                const x = (i % cols) * charSize + charSize / 2;
                const y = Math.floor(i / cols) * charSize + charSize / 2;
                ctx.fillText(charSet[i], x, y);
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.magFilter = THREE.NearestFilter;
            texture.minFilter = THREE.NearestFilter;
            
            return texture;
        }

        // Initialize Three.js scene
        function init() {
            if (!fontLoaded) return;
            
            const container = document.getElementById('ascii-hero');
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);

            // Camera setup
            camera = new THREE.PerspectiveCamera(
                75, 
                container.clientWidth / container.clientHeight, 
                0.1, 
                1000
            );
            camera.position.set(0, 0, config.cameraDistance);

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ 
                canvas: document.getElementById('canvas'), 
                antialias: true,
                alpha: true // Enable transparency if needed
            });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(5, 5, 5);
            scene.add(directionalLight);

            // Controls (optional)
            if (config.enableOrbitControls) {
                controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                controls.enableZoom = false; // Disable zoom for hero section
            }

            // Create ASCII texture
            asciiTexture = createAsciiTexture(fullAsciiSet);

            // Create ASCII post-processing effect
            createAsciiEffect();

            // Load the model
            loadModel();

            // Event listeners
            window.addEventListener('resize', onWindowResize);

            // Start animation loop
            animate();
        }

        // Create ASCII shader effect
        function createAsciiEffect() {
            const vertexShader = `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `;

            const fragmentShader = `
                uniform sampler2D tDiffuse;
                uniform sampler2D tAscii;
                uniform vec2 resolution;
                uniform float charSize;
                uniform float brightness;
                uniform float contrast;
                uniform float numChars;
                uniform float atlasSize;
                varying vec2 vUv;

                float gray(vec3 color) {
                    return dot(color, vec3(0.299, 0.587, 0.114));
                }

                void main() {
                    vec2 cellSize = vec2(charSize) / resolution;
                    vec2 cellPos = floor(vUv / cellSize);
                    vec2 cellUv = cellPos * cellSize + cellSize * 0.5;
                    
                    vec4 sceneColor = texture2D(tDiffuse, cellUv);
                    vec3 color = sceneColor.rgb;
                    float alpha = sceneColor.a;
                    
                    float isBackground = step(length(color), 0.01);
                    
                    if (isBackground > 0.5) {
                        gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
                        return;
                    }
                    
                    float grayValue = gray(color);
                    
                    grayValue = (grayValue - 0.5) * contrast + 0.5;
                    grayValue = grayValue * brightness;
                    grayValue = clamp(grayValue, 0.0, 1.0);
                    
                    float charIndex = floor(grayValue * (numChars - 1.0) + 0.5);
                    
                    float cols = 16.0;
                    float rows = ceil(numChars / cols);
                    vec2 atlasUv = vec2(
                        mod(charIndex, cols) / cols,
                        floor(charIndex / cols) / rows
                    );
                    
                    vec2 inCellUv = mod(vUv * resolution / charSize, 1.0);
                    vec2 charUv = atlasUv + inCellUv / vec2(cols, rows);
                    
                    vec4 asciiChar = texture2D(tAscii, charUv);
                    
                    vec3 finalColor = vec3(asciiChar.r) * 0.98;
                    gl_FragColor = vec4(finalColor, alpha);
                }
            `;

            asciiPass = {
                uniforms: {
                    tDiffuse: { value: null },
                    tAscii: { value: asciiTexture },
                    resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                    charSize: { value: config.charSize },
                    brightness: { value: config.brightness },
                    contrast: { value: config.contrast },
                    numChars: { value: fullAsciiSet.length },
                    atlasSize: { value: 16.0 }
                },
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                material: null,
                fsQuad: null,
                render: function(renderer, writeBuffer, readBuffer) {
                    if (!this.material) {
                        this.material = new THREE.ShaderMaterial({
                            uniforms: this.uniforms,
                            vertexShader: this.vertexShader,
                            fragmentShader: this.fragmentShader
                        });
                        
                        const geometry = new THREE.PlaneGeometry(2, 2);
                        this.fsQuad = new THREE.Mesh(geometry, this.material);
                        this.scene = new THREE.Scene();
                        this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
                        this.scene.add(this.fsQuad);
                    }

                    this.uniforms.tDiffuse.value = readBuffer.texture;
                    
                    if (writeBuffer) {
                        renderer.setRenderTarget(writeBuffer);
                        renderer.clear();
                        renderer.render(this.scene, this.camera);
                    } else {
                        renderer.setRenderTarget(null);
                        renderer.render(this.scene, this.camera);
                    }
                }
            };
        }

        // Load model
        function loadModel() {
            fetch(config.modelPath)
                .then(response => response.arrayBuffer())
                .then(buffer => {
                    const loader = new GLTFLoader();
                    loader.parse(buffer, '', (gltf) => {
                        model = gltf.scene;
                        scene.add(model);
                        centerModel();
                    }, (error) => {
                        console.error('Error loading model:', error);
                    });
                })
                .catch(error => {
                    console.error('Error fetching model:', error);
                });
        }

        // Center and scale model
        function centerModel() {
            const box = new THREE.Box3().setFromObject(model);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            
            const maxDim = Math.max(size.x, size.y, size.z);
            const scale = 3.5 / maxDim;
            
            model.scale.setScalar(scale);
            model.position.sub(center.multiplyScalar(scale));
            
            // Adjust camera if needed
            camera.position.set(0, 0, config.cameraDistance);
            if (controls) {
                controls.target.set(0, 0, 0);
                controls.update();
            }
        }

        // Window resize handler
        function onWindowResize() {
            const container = document.getElementById('ascii-hero');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
            asciiPass.uniforms.resolution.value.set(container.clientWidth, container.clientHeight);
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            if (controls) {
                controls.update();
            }
            
            // Auto rotation
            if (config.autoRotate && model) {
                model.rotation.y += config.rotationSpeed;
            }
            
            // Render scene to render target
            const renderTarget = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, {
                format: THREE.RGBAFormat,
                type: THREE.UnsignedByteType
            });
            renderer.setRenderTarget(renderTarget);
            renderer.setClearAlpha(0);
            renderer.clear();
            renderer.render(scene, camera);
            
            // Apply ASCII effect
            renderer.setRenderTarget(null);
            renderer.setClearAlpha(0);
            renderer.clear();
            asciiPass.render(renderer, null, renderTarget);
            
            renderTarget.dispose();
        }
    </script>
</body>
</html>